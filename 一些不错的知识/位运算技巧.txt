位运算:

Integer的最值问题:
Integer.MIN_VALUE(0x80000000) 
1000 0000 0000 0000 0000 0000 0000 0000
System.out.println(1 << 31);
System.out.println(1 << -1);

Integer.MAX_VALUE(0x7fffffff)
0111 1111 1111 1111 1111 1111 1111 1111
System.out.println((1 << 31) - 1);// 2147483647， 由于优先级关系，括号不可省略
System.out.println(~(1 << 31));// 2147483647

-1(0xFFFFFFFF)
1111 1111 1111 1111 1111 1111 1111 1111

Integer.MAX_VALUE + 1 = Integer.MIN_VALUE
Integer.MIN_VALUE - 1 = Integer.MAX_VALUE


Long的最值问题:
Long.MIN_VALUE(0x8000000000000000L)
8    0    0    0    0    0    0    0    0    0    0    0    0    0    0    0
1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
System.out.println(((long)1 << 127) - 1)

Long.MAX_VALUE(0x7fffffffffffffffL)
7    f    f    f    f    f    f    f    f    f    f    f    f    f    f    f
0100 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 


一- 与&:两个位都为 1 时，结果才为 1
1.单个位与1做&运算结果都为原位
2.判断奇偶数
只要根据最未位是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数 (a & 1) == 0
3.判断一个数n是不是2的幂
System.out.println((n & (n - 1)) == 0)
分析:如果是2的幂，n一定是100... n-1就是1111.... 所以做与运算结果为0
4.对2的n次方取余
System.out.println(m & (n - 1))
分析:n为2的次方  如果是2的幂，n一定是100... n-1就是1111....  所以做与运算结果保留m在n范围的非0的位  HashMap中也是这么用的

二- 或|:两个位都是 0 时，结果才为 0

三- 异或^:两个位相同时为 0，相异为 1
理解1:找出两个数有差异的位，a^b得到的结果中，1表示在该位两数存在差别，0表示无差别
理解2:将一个数按照另一个数的对应位的取值改变取值，如a^b(10001010^00110011)，可以看成a按照b的要求改变对应位的取值（1为改变，0为不改变）故得到10111001
理解3:异或是半加器,就是不带进位的加法运算
1.单个位与0做^运算,结果为原位
2.单个位与1做^运算,结果为取反
3.一个数和自己异或的结果为 0 
4.交换两数
a ^= b;
b ^= a;
a ^= b;
5.求两个数最大值
System.out.println(b&((a-b)>>31) | a&(~(a-b)>>31))
分析:b&((a-b)>>31) 若a>b 则(a-b)>>31为0 b&0=0    若a<b 则(a-b)>>31为-1 b&-1=b 
	 a&(~(a-b)>>31) 若a>b 则a-b为正数 最高位为0 ~(a-b)的最高位为1 ~(a-b)>>31则为-1 此时a&-1=a  若a<b  则最后得出a&0=0
	 最后(b&((a-b)>>31) | a&(~(a-b)>>31))综合来看 若a>b 0|a=a 若a<b b|0=b 完美解决两数中求最大值
6.求两个数最小值
System.out.println(a&((a-b)>>31) | b&(~(a-b)>>31))
分析:与上述问题5差不多
7.判断符号是否相同(true 表示 x和y有相同的符号， false表示x，y有相反的符号。)
System.out.println((x ^ y) > 0)
分析:x^y 最高位如果相同则为0 最高位如果不同为1 当最高位为0时 则为正数 判别式>0 当最高位为1时 则为负数 判别式<0

四- 取反~:0 变 1，1 变 0
1.变换符号  变换符号就是正数变成负数，负数变成正数
// 11
[0000 1011]补 --> 取反(~) --> [1111 0100] --> 加 1 --> [1111 0101]补( -11 )
// -11
[1111 0101]补 --> 取反(~) --> [0000 1010] --> 加 1 --> [0000 1011]补( 11 )
int a = -11, b = 11;
System.out.println(~a + 1);//-11
System.out.println(~b + 1);//11
2.求绝对值 
法1:位操作也可以用来求绝对值，对于负数可以通过上面变换符号方式对其取反后加1来得到正数。因此先移位来取符号位，int i = a >> 31; 要注意如果 a 为正数，i 等于 0，为负数，i 等于 -1。然后对i进行判断——如果i等于0，直接返回。否之，返回~a+1
int i = a >> 31;//取符号位  要么为0 要么为-1(0xFFFFFFFF)
System.out.println(i == 0 ? a : (~a + 1));

法2:对于任何数，与 0 异或都会保持不变，与 -1(0xFFFFFFFF)异或就相当于取反。因此，a 与 i 异或后再减 i（因为 i 为 0 或 -1，所以减 i即是要么加 0要么加 1）也可以得到绝对值。所以可以对上面代码优化下：
int i = a >> 31;//取符号位  要么为0 要么为-1(0xFFFFFFFF)
System.out.println((a ^ i) - i);
分析:i要么为0,要么为-1 a^i相当于a^0=a 或者a^-1=a取反 若i=0 -i相当于0 没变 若i=-1 -i相当于-1取绝对值(0xFFFFFFFF取反加1 = 0x00000001)  所以如果i=-1 那么a^i-i 就相当于a取反加一   如果i=0 那么a^i-i 相当于a没变
3.求n+1
-~n
分析:~n 给n取反 再变负 变负时会做取反加1的操作 最后相当于给n+1
4.计算n-1
~-n
分析:-n 就是给n取反加1 再取反 相当于减1
5.取相反数
~n + 1
或者(n ^ -1) + 1
分析:n^-1 相当于 n^(0xFFFFFFFF) 其实就是给n取反 最后再加1  取得相反数


五- 左移<<:各二进位全部左移若干位，高位丢弃，低位补 0
1.10乘以2运算
System.out.println(10<<1)
2.10乘以2的m次方
System.out.println(10<<m)
3.计算2的n次方 n > 0
System.out.println(2<<(n-1)) 或者System.out.println(1<<n)
4.从低位到高位.将n的第m位置为1
System.out.println(n | (1<<(m-1)))
分析:将1左移m-1位找到第m位，得到000...1...000 n再和这个数做或运算
5.从低位到高位,将n的第m位置为0
System.out.println(n & ~(0<<(m-1)))
分析:将1左移m-1位找到第m位，取反后变成111...0...1111 n再和这个数做与运算



六- 右移>>:丢弃右边指定位数，左边补上符号位
1.10除以2运算
System.out.println(10>>1)
2.10除以2的m次方
System.out.println(10>>m)
3.求两个整数的平均值
System.out.println((a+b) >> 1)  
或者System.out.println(((x ^ y) >> 1) + (x & y))
分析:(x^y) >> 1得到x，y其中一个为1的位并除以2，x&y得到x，y都为1的部分，加一起就是平均数了
4.从低位到高位,取n的第m位
int m = 2;
System.out.println((n >> (m-1)) & 1)
分析:先将n右移(m-1)位 就是把第m位移到最右端  再与&1做运算即可


七- 无符号右移>>>:丢弃右边指定位数，左边补上0


