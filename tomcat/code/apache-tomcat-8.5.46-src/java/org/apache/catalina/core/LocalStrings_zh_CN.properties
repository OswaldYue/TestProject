# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

applicationContext.addJspFile.iae=JSP 文件 [{0}] 不可用
applicationContext.addListener.iae.cnfe=无法创建类型为 [{0}] 的实例
applicationContext.addListener.iae.wrongType=指定的类型[{0}]不是预期的侦听器类型之一
applicationContext.addRole.ise=上下文被初始化后，角色不能再被添加到[{0}]中
applicationContext.attributeEvent=属性事件监听器引发的异常
applicationContext.invalidServletName=由于servlet名称[{0}]无效，无法添加对应servlet的定义。
applicationContext.mapping.error=映射中.的错误
applicationContext.setAttribute.namenull=Name 不能为 null
applicationContext.setSessionTracking.iae.ssl=为上下文 [{0}] 请求的 session 跟踪模式包括 SSL 和至少一种其他模式。 SSL可能未配置其他模式。
applicationContext.setSessionTracking.ise=当上下文正在运行，无法设置上下文[{0}]的会话跟踪模式

applicationDispatcher.specViolation.response=原始的ServletResponse或包装后的ServletResponse未传递给RequestDispatcher，原因：违反了SRV.8.2和SRV.14.2.5.1\n\
\n

applicationFilterConfig.release=失败的销毁过滤器类型为[{1}]名称为[{0}]

applicationFilterRegistration.nullInitParams=由于name和(或)value为null，无法为过滤器设置初始化参数。name为 [{0}]，value为 [{1}]

applicationPushBuilder.methodNotToken=HTTP方法必须是令牌(token)，但 [{0}] 包含非令牌字符

aprListener.aprInitError=基于APR的本地库加载失败.错误报告为[{0}]
aprListener.initializeFIPSSuccess=成功的进入FIPS 模式
aprListener.initializingFIPS=初始化FIPS模式...
aprListener.tcnVersion=安装了基于APR的Apache Tomcat Native库的旧版本[{0}]，而Tomcat建议使用[{1}]的最低版本
aprListener.tooLateForFIPSMode=无法设置FIPSMode：SSL已初始化
aprListener.tooLateForSSLRandomSeed=无法设置 SSLRandomSeed：SSL已经初始化

asyncContextImpl.requestEnded=AsyncContext关联的请求已经完成处理。

containerBase.backgroundProcess.cluster=异常处理集群[{0}]后台进程
containerBase.backgroundProcess.unexpectedThreadDeath=后台线程[{0}]意外结束
containerBase.nullName=容器名称不能为null
containerBase.threadedStartFailed=子容器启动失败

defaultInstanceManager.invalidInjection=方法资源注入注解无效
defaultInstanceManager.restrictedContainerServlet=禁止访问类 [{0}]。 它是一个受限制的类（实现了 ContainerServlet 接口）。 必须将 Web 应用程序配置为特权才能加载它
defaultInstanceManager.restrictedFiltersResource=找不到受限制的过滤器属性文件[{0}]
defaultInstanceManager.restrictedListenersResource=无法找到RestrictedListener的配置文件[{0}]

filterChain.filter=Filter 执行抛出一个异常

naming.addEnvEntry=添加环境条目 [{0}]
naming.addResourceEnvRef=添加资源环境引用 [{0}]
naming.invalidEnvEntryType=环境条目[{0}]没有一个有效哦的类型
naming.jmxRegistrationFailed=注册到JMX失败：[{0}]
naming.namingContextCreationFailed=创建上下文名称失败
naming.wsdlFailed=未找到 wsdl 文件：[{0}]

standardContext.applicationListener=配置应用程序监听器[{0}]错误
standardContext.backgroundProcess.resources=异常处理资源[{0}] 后台进程
standardContext.cookieProcessor.null=不允许将上下文的CookieProcessor 设置为null
standardContext.errorPage.required=ErrorPage不能为null
standardContext.errorPage.warning=警告：在Servlet 2.4中，错误页位置 [{0}] 必须以"/"开头
standardContext.extensionValidationError=尝试校验必需的应用程序扩展时发生错误
standardContext.filterMap.either=过滤器映射必须指定 <url-pattern> 或 <servlet-name>
standardContext.filterMap.name=Filter mapping 指定了一个未知的 filter名称 [{0}]
standardContext.filterMap.pattern=过滤器映射中的<url-pattern> [{0}] 无效
standardContext.filterStart=启动过滤器异常
standardContext.invalidWrapperClass=[{0}] 不是StandardWrapper的子类
standardContext.isUnavailable=此应用程序目前不可用
standardContext.listenerStart=异常将上下文初始化事件发送到类的侦听器实例.[{0}]
standardContext.loginConfig.errorPage=表单错误页[{0}]必须以"/"开始
standardContext.loginConfig.errorWarning=警告：Servlet 2.4中，表单错误页[{0}]必须以"/"开始
standardContext.loginConfig.loginPage=表单登录页面 [{0}] 必须以''/''开头
standardContext.manager=配置类为[{0}]的管理器
standardContext.managerFail=会话管理器无法启动
standardContext.namingResource.init.fail=未能初始化新的命名资源
standardContext.notStarted=名称为[{0}]的上下文还没有启动
standardContext.parameter.duplicate=重复的上下文初始化参数[{0}]
standardContext.predestroy.duplicate=类 [{0}] 的 @PreDestroy 方法定义重复
standardContext.resourcesInit=初始化静态变量错误
standardContext.resourcesStart=启动静态资源出错
standardContext.resourcesStop=停止静态资源时出错
standardContext.securityConstraint.mixHttpMethod=在相同的web资源集合中不允许混用: <http-method> 和 <http-method-omission>
standardContext.securityConstraint.pattern=安全约束中的<url-pattern> [{0}] 无效
standardContext.servletFail=启动时无法加载一个或多个Servlet。 全部的详细信息可在相应的容器日志文件中找到
standardContext.startingContext=启动Context[{0}]出现异常
standardContext.stop.asyncWaitInterrupted=等待卸载延迟毫秒以完成飞行中的异步请求时收到中断。上下文停止将继续，不会有进一步的延迟。
standardContext.stoppingContext=异常停止的上下文使用名为[{0}]
standardContext.workCreateFail=无法为上下文[{1}]创建工作目录[{0}]

standardContextValve.acknowledgeException=以100（继续）响应确认请求失败

standardEngine.notParent=引擎不能有父容器

standardHost.noContext=没有配置上下文来处理此请求
standardHost.notContext=主机的子节点必须有上下文

standardServer.accept.timeout=在调用accept()方法之后，侦听shutdown命令的套接字经历了意外的超时[{0}]毫秒。 这是bug 56684的一个例子？
standardServer.storeConfig.notAvailable=没有将StoreConfig实现注册为名为[{0}]的MBean，因此无法保存配置。合适的MBean通常通过StoreConfigLifecycleListener注册。

standardService.engine.stopFailed=失败停止关联的引擎

standardWrapper.destroyInstance=servlet[{0}]实例管理销毁(destroy) 抛出异常
standardWrapper.isUnavailable=Servlet [{0}]当前不可用。
standardWrapper.notChild=Wrapper容器内部不允许有子容器。
standardWrapper.notFound=Servlet [{0}] 不可用
standardWrapper.unloading=无法分配servlet [{0}]，因为它没有被加载

threadLocalLeakPreventionListener.containerEvent.error=异常处理容器事件[{0}]
