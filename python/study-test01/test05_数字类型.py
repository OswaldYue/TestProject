#! user/bin/python3
# -*- coding:utf-8 -*-

# Python3 数字(Number)

# Python 数字数据类型用于存储数值
# 数据类型是不允许改变的,这就意味着如果改变数字数据类型的值，将重新分配内存空间
# 以下实例在变量赋值时 Number 对象将被创建：
var1 = 1
var2 = 10
var3 = 100

# 也可以使用del语句删除一些数字对象的引用。
# del语句的语法是：
# del var1[,var2[,var3[....,varN]]]
# 可以通过使用del语句删除单个或多个对象的引用，例如：
del var1
del var2, var3

# Python 支持三种不同的数值类型：
# 整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型
# 浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 10^2(10的2次幂) = 250）
# 复数( (complex)) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型
# 可以使用十六进制和八进制来代表整数：
0xA0F # 十六进制 十进制的2575
0o37  # 八进制十进制的31

# Python 数字类型转换
# 有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可
# int(x) 将x转换为一个整数
# float(x) 将x转换到一个浮点数  python 不支持复数转换为整数或浮点数  float(4.5+0j)会报TypeError: can't convert complex to float
# complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0
# complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式
# 以下实例将浮点数变量 a 转换为整数：
a = 1.0
print(int(a))  # 1

# 不同类型的数混合运算时会将整数转换为浮点数：
b = 3 * 3.75 / 1.5
print(b)  # 7.5



# 数学函数
# 函数	              返回值 ( 描述 )
# abs(x)	          返回数字的绝对值，如abs(-10) 返回 10
# ceil(x)	          返回数字的上入整数，如math.ceil(4.1) 返回 5
# cmp(x, y)           如果 x < y 返回 -1, 如果 x == y 返回 0, 如果 x > y 返回 1。 Python 3 已废弃，使用 (x>y)-(x<y) 替换
# exp(x)	          返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045
# fabs(x)	          返回数字的绝对值，如math.fabs(-10) 返回10.0
# floor(x)	          返回数字的下舍整数，如math.floor(4.9)返回 4
# log(x)	          如math.log(math.e)返回1.0,math.log(100,10)返回2.0
# log10(x)	          返回以10为基数的x的对数，如math.log10(100)返回 2.0
# max(x1, x2,...)	  返回给定参数的最大值，参数可以为序列
# min(x1, x2,...)	  返回给定参数的最小值，参数可以为序列
# modf(x)	          返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示
# pow(x, y)	          x**y 运算后的值
# round(x [,n])	      返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数
# sqrt(x)	          返回数字x的平方根
# 注意:  round()函数四舍五入的讨论
print("=========================1=======================")
print(round(10.4)) #10
print(round(10.5)) #10
print(round(10.6)) #11
print("=========================2=======================")
print(round(11.4)) #11
print(round(11.5)) #12
print(round(11.6)) #12
# 由运行得出结论：
# 当小数点左边为偶数：小数点右边X<6，舍
# 当小数点左边为偶数：小数点右边X>=6，入
# 当小数点左边为奇数：小数点右边X<5，舍
# 当小数点左边为奇数：小数点右边X>=5，入
# 所以当小数点左边分别为奇数和偶数的时候，小数点右边的取舍也分别对应两种取舍标准
print("==========================3=======================")
print(round(10.49))  #10
print(round(10.50))  #10
print(round(10.51))  #11
print(round(11.50))  #12
print(round(11.49))  #11
# 当个位为奇数，小数部分>=0.5入，其余为舍
# 当个位为偶数，小数部分>0.5入，其余为舍

# “4舍6入5看齐,奇进偶不进”我觉得并不是因为浮点数在计算机表示的问题。计算机浮点数的表示是 ieee 定义的标准规则，如果 python 中存在，没道理其他语言中不存在。事实上是因为该取舍方法比过去的 "四舍五入" 方法在科学计算中更准确。
# 而国家标准也已经规定使用 “4舍6入5看齐,奇进偶不进” 取代"四舍五入".
# 从统计学的角度上来讲,如果大量数据无脑的采用四舍五入会造成统计结果偏大。而"奇进偶舍"可以将舍入误差降到最低
# 奇进偶舍是一种比较精确比较科学的计数保留法，是一种数字修约规则
# 其具体要求如下（以保留两位小数为例）：
# (1)要求保留位数的后一位如果是4或者4以下的数字，则舍去， 例如 5.214保留两位小数为5.21
# (2)如果保留位数的后一位如果是6或者6以上的数字，则进上去， 例如5.216保留两位小数为5.22
# (3)如果保留位数是保留整数部分或保留一位小数，则要根据保留位来决定奇进偶舍：
print("==========================4=======================")
print(round(5.215,2))#实际并没有进位   5.21
print(round(5.225,2))  #5.22
print(round(1.5)) #此处进位 2
print(round(1.5)==round(2.5))#偶数舍去  True
print(round(1.15,1)) #1.1
print(round(1.25,1)) #1.2
print(round(1.151,1)) #1.2
print(round(1.251,1)) #1.3
# (4) 如果保留位数的后一位如果是5，且该位数后有数字。则进上去，例如5.2152保留两位小数为5.22，5.2252保留两位小数为5.23，5.22500001保留两位小数为5.23  若没有数字 则舍去 例如5.215保留2位小数5.21
# 从统计学的角度，“奇进偶舍”比“四舍五入”要科学，在大量运算时，它使舍入后的结果误差的均值趋于零，而不是像四舍五入那样逢五就入，导致结果偏向大数，使得误差产生积累进而产生系统误差，“奇进偶舍”使测量结果受到舍入误差的影响降到最低

# Python3中已经不能使用cmp()函数了，被如下五个函数替代:
import operator       #首先要导入运算符模块
print("===========================5=======================")
print(operator.gt(1,2))      #意思是greater than（大于）
print(operator.ge(1,2))      #意思是greater and equal（大于等于）
print(operator.eq(1,2))      #意思是equal（等于）
print(operator.le(1,2))      #意思是less and equal（小于等于）
print(operator.lt(1,2))      #意思是less than（小于）


# 随机数函数
# 随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性
# Python包含以下常用随机数函数：
# 函数	                                     描述
# choice(seq)	                             从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数
# randrange ([start,] stop [,step])          从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1
# random()	                                 随机生成下一个实数，它在[0,1)范围内
# seed([x])	                                 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed
# shuffle(lst)	                             将序列的所有元素随机排序
# uniform(x, y)	                             随机生成下一个实数，它在[x,y]范围内
# randint(x,y)　                             随机生一个整数int类型，可以指定这个整数的范围   random.randint(1000,9999)
# random.sample(sequence,length)             可以从指定的序列中，随机的截取指定长度的片断，不修改原序列   random.sample('abcd1234',4)

# 三角函数
# Python包括以下三角函数：
# 函数	           描述
# acos(x)	       返回x的反余弦弧度值
# asin(x)	       返回x的反正弦弧度值
# atan(x)	       返回x的反正切弧度值
# atan2(y, x)	   返回给定的 X 及 Y 坐标值的反正切值
# cos(x)	       返回x的弧度的余弦值
# hypot(x, y)	   返回欧几里德范数 sqrt(x*x + y*y)
# sin(x)	       返回的x弧度的正弦值
# tan(x)	       返回x弧度的正切值
# degrees(x)	   将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0
# radians(x)	   将角度转换为弧度


# fractions 模块提供了分数类型的支持。
# 构造函数：
# class fractions.Fraction(numerator=0, denominator=1) 
# class fractions.Fraction(int|float|str|Decimal|Fraction)
# 可以同时提供分子（numerator）和分母（denominator）给构造函数用于实例化Fraction类，但两者必须同时是int类型或者numbers.Rational类型，否则会抛出类型错误。
# 当分母为0，初始化的时候会导致抛出异常ZeroDivisionError。
from fractions import Fraction
print("===========================6=======================")

x=Fraction(1,3)
y=Fraction(4,6)
print(x) #1/3
print(y) #2/3
print(x+y)  # 1 分数的好处就是有时可以避免无法除尽的情况  例如1/3 + 4/6按其他运算符的运算1/3=0.33333333333333333 这就导致这个等式本来应该等于1 确结果为一串小数的情况 
print(Fraction(1, 1)) #1
print(Fraction('.25'))  #1/4
print(Fraction(1, 4))  #1/4
# 浮点数与分数的转换：
print("===========================7=======================")
f=2.5
z=Fraction(*f.as_integer_ratio())
print(z)  #5/2
print(Fraction(5, 2))  #5/2
x=Fraction(1,3) 
print(x)   #1/3
print(float(x))  #0.33333333333333333333333

# decimal 模块提供了一个 Decimal 数据类型用于浮点数计算，拥有更高的精度

import decimal
print("===========================8=======================")
decimal.getcontext().prec=4             # 指定精度（4位小数）
a = decimal.Decimal(1) / decimal.Decimal(7)
print(a)  #0.1429
print(decimal.Decimal('0.1429'))  #0.1429 



# 关于Python整数比较的一些坑：
# Python中一切都是对象，对象比较可以用 == 或者 is
# == 比较的是两个对象的内容是否相等，默认会调用对象的 __eq__() 方法
# is 比较的是两个对象的 id 是否相等，也就是是否是同一个对象，是否指向同一个内存地址
print("===========================9=======================")
a = 4
b = 4
print(a == b)  #True
print(a is b)  #True
a = 256
b = 256
print(a == b)  #True
print(a is b)  #True
a = 257
b = 257
print(a == b)  #True
print(a is b)  #True  这里与交互式编程的方式有点儿不同  交互式是False 而脚本式则为True  原因暂时不知
# 解释一下最后一组的交互式为False的一些说明
# 前几组比较我们都可以理解显示的结果，但是最后当 a/b 都指向 257 这个整数对象的时候，交互式时用 is 比较以后的结果是 False
# 这是因为 Python 处于对性能的考虑，内部作了优化，对于整数对象，把一些频繁使用的整数对象缓存起来，保存到一个叫 small_ints 的链表中
# 在 Python 整个生命周期中，任何需要引用这些整数对象的地方，都不再重新创建新的整数对象，范围是 [-5,256]
# 再看下面这个例子 ：
a = 259
def foo () :
    b = 259
    c = 259
    print(a is b)  # False
    print(b is c)  # True
foo()
# 这是因为 Python 程序都是由代码块构成，代码块作为程序的一个最小基本单位来执行。一个模块文件/一个函数体/一个类/交互式命令中的单行代码都叫做一个代码块
# 上面的程序中有两部分代码块，一个是名称 a 所在的代码块，一个是名称 b/c 所在的代码块
# Python 的另一个优化的地方就是，如果在同一个代码块中创建的两个整数对象中，它们的值相等的话，那么这两个对象引用同一个整数对象
# 所以Python出于对性能的考虑，但凡是不可变的对象，在同一代码块中，只有值相等的对象就不会重复创建，而是直接引用已经存在的对象。不仅整数对象，字符串对象也遵循同样的原则


# 数字与字符，列表之间的转换
# 1、字符转为数字
print("===========================10=======================")
var='1234'
num=int(var) # 如果是小数可用 float
print(num)
# 2、字符转为列表
num_list=list(var)
print(num_list)
# 3、列表转为数组
# 可以用 numpy 模块(numpy模块需要安装)：
# import numpy as np
# num_array=np.array(num_list)
# 也可以是 num_array=[int(i) for i in num_list]


# 一定要注意 += 和 =+ 的不同
# 实例 1：
print("===========================11=======================")
a = 5
a += 6
print(a)
# 以上实例与下面实例的效果一样：
a = 5
a = a + 6
print(a)
# 实例2：
b = 5
b =+ 6
print(b)

# 为什么会是 6 而不是 11 呢? 因为实例2与下面代码一样：
b = 5
b = +6  # 其实就是正数，只是一个赋值操作，+ 6 即为 +6，+6 为 6
print(b)
# 一定要分清 += 和 =+ 哦！另外要注意 Python 可是没有 a++ 指令的！


# 数学常量
# 常量	     描述
# pi	     数学常量 pi（圆周率，一般以π来表示）
# e	         数学常量 e，e即自然常数（自然常数）












