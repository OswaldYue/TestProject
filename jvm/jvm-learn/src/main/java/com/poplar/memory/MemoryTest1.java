package com.poplar.memory;

/**
 * jvm管理的内存:
 * 本地方法栈：主要用于处理本地方法
 * 程序计数器：jvm没有规定可以产生内存溢出
 * 虚拟机栈：
 *  -栈帧：
 *      局部变量表
 *      方法返回地址
 *      操作数栈
 *      动态链接
 *
 * 堆：在物理内存上可以连续，也可以不连续。jvm管理的最大的一块内存空间，通常new出来的对象，存放此处，与堆相关的一个重要概念是垃圾收集器，现代几乎所有的垃圾收集器都是采用分代收集算法。
 *  所以，堆空间也基于这一点进行相应的划分：新生代与老年代。再具体分，Eden空间，From Survivor空间与To Survivor空间。
 * 方法区：存储一些元信息，常量，Class对象等。某些人称为永久代，从jdk1.8开始，已经彻底废弃了永久代，使用元空间(Meta space)代替。
 *  元空间使用的是操作系统的本地内存，可以是不连续的，可以产生outofmemory的情况
 *  -运行时常量池:方法区的一部分内容
 * 直接内存(Direct memory)；与java NIO密切相关，jvm通过堆上的DirectByteBuffer来操作直接内存。
 * */
/**
 * 当创建一个对象时，会在堆中创建，新建的对象其实有两部分，第一部分为自身的数据，第二部分为元数据(此对象对应的Class数据)
 * 此时有两种方式来部署这个对象，第一种，堆中创建一个句柄池，两个指针，一个指针指向自身数据部分，一个指针指向方法区此类的Class部分
 * 第二种，堆中直接开辟一个空间，此空间直接放此类的自身数据，然后此空间中的一个指针指向方法区此类的Class部分
 * */

import java.util.ArrayList;
import java.util.List;

/**
 * 关于java对象创建的过程:
 * new关键字创建对象的3个步骤:
 * 1.在堆内存中创建出实例
 * 2.为对象的实例成员变量赋初值以及初始化<init>
 * 3.将对象的引用返回
 * 对象在堆上开辟内存的过程中，可能不会有连续的空间，如此就需要按以下的原则进行内存寻找:
 *  -指针碰撞(前提是堆中的空间通过一个指针进行分割，一侧是已经被占用的空间，另一侧是未被占用的空间)
 *  -空闲列表(前提是堆内存空间中已被使用与未被使用的空间是交织在一起的，这时，虚拟机就需要通过一个列表来记录哪些空间是可以使用的，
 *  哪些空间是已被使用的，接下来找出可以容纳下新创建对象的且未被使用的空间，在此空间存放该对象，同时还要修改列表上的记录)
 *
 * 对象在内存中的布局:
 * 1.对象头.
 * 2.实例数据(即我们在一个类中所声明的各项信息)
 * 3.对齐填充(可选)
 *
 * 引用访问对象的方式:
 * 1.使用句柄的方式。
 * 2.使用直接指针的方式。hotspot使用此种方式
 * */
/**
 * 堆的OutOfMemoryError
 * */
public class MemoryTest1 {

    private String[] strings = new String[1024];

    public static void main(String[] args) {
        //-Xms5m -Xmx5m -XX:+HeapDumpOnOutOfMemoryError 设置jvm对空间最小和最大以及遇到错误时把堆存储文件打印出来
        //打开jvisualvm装在磁盘上的转存文件
        List<MemoryTest1> list = new ArrayList<>();
        while (true) {
            list.add(new MemoryTest1());
            System.gc();
        }
    }

}
